---
title: Boats Number
---

```{r no cache setup, results='hide', message=FALSE, warning=FALSE, cache=FALSE, include=FALSE}

# A general-purpose tool for dynamic report generation in R
library(knitr)

# Adds features to a kable output
library(kableExtra)

# Format R code automatically
library(styler)

# Prints an R object in markdown, needed to print pretty table from list of dfs.
library(pander)


```

```{r df format setup}
#| include: false
# kable <- function(data) {
#   knitr::kable(data, booktabs = true, digits = 2) %>%
#     kable_styling('striped', full_width = FALSE)
# }

knit_print.data.frame = function(x, ...) {
  res = paste(c(
    '',
    '',
    knitr::kable(x, digits = 2) |>
      kableExtra::kable_styling('striped', full_width = FALSE)
  ),
  collapse = '
')
  knitr::asis_output(res)
}

registerS3method(
  'knit_print', 'data.frame', knit_print.data.frame,
  envir = asNamespace('knitr')
)

# knitr::opts_chunk$set(echo = TRUE)

# options(knitr.table.format = 'HTML')
```

# Prepare data

## setup current project 

```{r setup current project, results='hide', message=FALSE, warning=FALSE}
# setup current project ----
library(zoo)
# Determine the path of the executing script
library(this.path)

source("~/R_code_github/useful_functions_module.r")
my_paths <- set_work_dir()

# Get the current project directory name using the 'this.path' package.
current_project_dir_name <- this.path::this.dir()
```

### additional data 

```{r additional data}
## additional data ----
# for qmd use #' {{< include .qmd >}} instead of # source()

misc_info_path <-
  file.path(my_paths$git_r,
            r"(get_data\misc_info.R)")
# source(misc_info_path)
```

{{< include misc_info.qmd >}}

### logbooks data

```{r logbooks data}
## logbooks data----
# for qmd use  #' {{< include .qmd >}} instead of # source()

# use all logbooks from https://drive.google.com/drive/folders/1HipnxawNsDjrsMc4dXgFwdRPQ3X6-x3n
# when is ready
all_logb_path <-
  file.path(my_paths$git_r,
            r"(get_data\all_logbooks_db_data_2022_short_p_region_prep.R)")
# source(all_logb_path)
```

{{< include all_logbooks_db_data_2022_short_p_region_prep.qmd >}}

### input data names 

```{r input data names}
## input data names ----
# all_get_db_data_result_l
# all_logbooks_db_data_2022_short_p_region

print_df_names(all_logbooks_db_data_2022_short_p_region)
# [1] "trip_id, trip_type_name, vessel_id, vessel_official_nbr, vessel_name, trip_start_date, trip_end_date, state, state_name, start_port, start_port_name, start_port_county, start_port_state, end_port, end_port_name, end_port_county, end_port_state, activity_type_name, accsp_permit_license_nbr, sero_vessel_permit, garfo_vessel_permit, vendor_app_name, vendor_platform, trip_de, trip_ue, trip_dc, trip_uc, area_code, sub_area_code, distance_code, distance_code_name, local_area_code, latitude, longitude, effort_de, effort_ue, effort_dc, effort_uc, catch_uc, user_app, notif_seq, notif_type, notif_accsp_system_id, notif_accsp_permit_id, notif_trip_type, notif_trip_type_name, notif_trip_start_date, notif_trip_start_time, notif_trip_end_date, notif_trip_end_time, notif_start_port, notif_start_port_name, notif_start_port_county, notif_start_port_state, notif_end_port, notif_end_port_name, notif_end_port_county, notif_end_port_state, notif_cancel_flag, notif_email_sent, notif_intended_fishing_flag, notif_gear_type, notif_landing_location, notif_landing_location_name, notif_landing_location_city, notif_landing_location_county, notif_landing_location_state, notif_stat_zone, notif_ue, notif_de, notif_uc, notif_dc, permit_region"
```

### remove unused fields from all_logbooks_db_data_2022_short_p_region 

```{r remove unused fields from all_logbooks_db_data_2022_short_p_region}
## remove unused fields from all_logbooks_db_data_2022_short_p_region ----
port_fields_short <-
  c(
    "vessel_id",
    "vessel_official_nbr",
    "permit_region",
    "start_port_name",
    "end_port_name",
    "start_port",
    "end_port"
  )

all_logbooks_db_data_2022_short_p_region_short <-
  all_logbooks_db_data_2022_short_p_region |>
  dplyr::select(dplyr::all_of(port_fields_short)) |>
  remove_empty_cols() |>
  dplyr::distinct()

dim(all_logbooks_db_data_2022_short_p_region_short)
# [1] 3011    7
```

## check port info 

```{r check port info}
# check port info ----
```

### port codes are different, but port names are the same 

```{r port codes are different, but port names are the same}
## port codes are different, but port names are the same ----
all_logbooks_db_data_2022_short_p_region_short |>
  dplyr::filter(!start_port == end_port &
           start_port_name == end_port_name) |>
  dplyr::glimpse()
# 2
# $ vessel_id           <int> 326764, 254794
# $ vessel_official_nbr <chr> "NC8438DJ", "FL0291MX"
# $ permit_region       <chr> "sa_only", "sa_only"
# $ start_port_name     <chr> "WRIGHTSVILLE BEACH", "KEYS FISHERIES"
# $ end_port_name       <chr> "WRIGHTSVILLE BEACH", "KEYS FISHERIES"
# $ start_port          <chr> "361133", "118530"
# $ end_port            <chr> "362333", "111949"

# all_logbooks_db_data_2022_short_p_region_short |>
#   filter(start_port == end_port &
#            !start_port_name == end_port_name) |>
# str()
# 0
```

### save specific field names for future use 

```{r save specific field names for future use}
## save specific field names for future use ----
port_fields_all <-
  function() {
    # Combine specific fields with names containing "port" from the given 'variables'.
    c(dplyr::all_of(c(
      "vessel_id",
      "vessel_official_nbr",
      "permit_region"
    )),
    dplyr::contains("port")
    # ,
    # -starts_with("notif")
    )
  }

  # Select specific columns using the 'port_fields_all' function, remove columns starting with "notif",
  # remove empty columns, and retain distinct rows.
all_logbooks_db_data_2022_short_p_region_port_fields_all <-
  all_logbooks_db_data_2022_short_p_region |>
  dplyr::select(port_fields_all(), -starts_with("notif")) |>
  remove_empty_cols() |>
  dplyr::distinct()

dim(all_logbooks_db_data_2022_short_p_region_port_fields_all)
# [1] 3011   11
```

### add date related columns 

```{r add date related columns}
## add date related columns ----
tic("all_logbooks_db_data_2022_short_p_region_dates")
all_logbooks_db_data_2022_short_p_region_dates <-
  all_logbooks_db_data_2022_short_p_region |>
  dplyr::mutate(
    trip_start_week_num =
      strftime(trip_start_date, format = "%u"),
    trip_end_week_num =
      strftime(trip_end_date, format = "%u"),
    trip_start_y =
      lubridate::year(trip_start_date),
    trip_end_y =
      lubridate::year(trip_end_date),
    trip_start_m =
      zoo::as.yearmon(trip_start_date),
    trip_end_m =
      zoo::as.yearmon(trip_end_date),
    trip_start_year_quarter = zoo::as.yearqtr(trip_start_date),
    trip_start_quarter_num =
      format(trip_start_year_quarter, "%q"),
    trip_end_year_quarter = zoo::as.yearqtr(trip_end_date),
    trip_end_quarter_num =
      format(trip_end_year_quarter, "%q")
  )
toc()
# all_logbooks_db_data_2022_short_p_region_dates: 2.94 sec elapsed
```

### shorten all_logbooks_db_data_2022_short_p_region_dates 

```{r shorten all_logbooks_db_data_2022_short_p_region_dates}
## shorten all_logbooks_db_data_2022_short_p_region_dates ----
# Select specific columns using the 'port_fields_all' function,
# select columns starting with "trip_",
# remove columns starting with "notif",
# remove empty columns, and retain distinct rows.

all_logbooks_db_data_2022_short_p_region_dates_trip_port <-
  all_logbooks_db_data_2022_short_p_region_dates |>
  dplyr::select(port_fields_all(),
                dplyr::starts_with("trip_"),
                -starts_with("notif")) |>
  remove_empty_cols() |>
  dplyr::distinct()

dim(all_logbooks_db_data_2022_short_p_region_dates_trip_port)
# [1] 94366    29
```

# Count boat numbers

## How many SEFHIER vessels start at a different location than they end 

```{r How many SEFHIER vessels start at a different location than they end}
# How many SEFHIER vessels start at a different location than they end ----

start_end_diff <-
  all_logbooks_db_data_2022_short_p_region_short |>
  # filter(!start_port == end_port) |>
  dplyr::filter(!start_port_name == end_port_name) |>
  dplyr::select(vessel_id,
         vessel_official_nbr,
         permit_region) |>
  dplyr::distinct() |>
  # dim()
  # Rows: 397
  count(permit_region)

start_end_diff

# 1  gom_and_dual 198
# 2       sa_only 199
# by name:
# 1  gom_and_dual 198
# 2       sa_only 197

# if keep ports:
# dim()
# 499
# 1  gom_and_dual 273
# 2       sa_only 226
```

## How many vessels have variable landing locations 

```{r How many vessels have variable landing locations}
# How many vessels have variable landing locations ----
```

I.e., in the winter they are in one state while in the summer they fish in another)

### multiple_start_ports 

```{r multiple_start_ports}
## multiple_start_ports ----
multiple_start_ports <-
  all_logbooks_db_data_2022_short_p_region_short |>
  dplyr::select(vessel_official_nbr,
                permit_region,
                start_port_name) |>
  dplyr::distinct() |>
  dplyr::add_count(vessel_official_nbr,
                   permit_region,
                   name = "start_port_name_cnt") |>
  dplyr::filter(start_port_name_cnt > 1) |>
  dplyr::arrange(vessel_official_nbr)

count_uniq_by_column(multiple_start_ports)
# vessel_official_nbr 675

head(multiple_start_ports)
```

#### test multiple_start_ports 

```{r test multiple_start_ports}
### test multiple_start_ports ----
multiple_start_ports |>
  dplyr::filter(vessel_official_nbr %in% c('944064',
                                    '934665')) |>
  head()
# 2,2
```

### multiple_end_ports 

```{r multiple_end_ports}
## multiple_end_ports ----

multiple_end_ports <-
  all_logbooks_db_data_2022_short_p_region_short |>
  # Select specific columns, retain distinct rows,
  # add a count end_port_name column for each combination of 'vessel_official_nbr' and 'permit_region'.
  dplyr::select(vessel_official_nbr,
                permit_region,
                end_port_name) |>
  dplyr::distinct() |>
  dplyr::add_count(vessel_official_nbr,
                   permit_region,
                   name = "end_port_name_cnt") |>
  # Filter for rows where the count of 'end_port_name' is greater than 1,
  # and arrange the data by 'vessel_official_nbr'.
  dplyr::filter(end_port_name_cnt > 1) |>
  dplyr::arrange(vessel_official_nbr)

head(multiple_end_ports)
```

#### test multiple_end_ports 

```{r test multiple_end_ports}
### test multiple_end_ports ----
multiple_end_ports |>
  dplyr::filter(vessel_official_nbr %in% c('944064',
                                    '934665')) |>
  head()
# 2 port names

count_uniq_by_column(multiple_end_ports)
# vessel_official_nbr 374
```

#### How many vessels have multiple end ports 

```{r How many vessels have multiple end ports}
### How many vessels have multiple end ports ----

multiple_end_ports |>
  select(vessel_official_nbr) |>
  distinct() |>
  count()
```

### multiple_end_port_states 

```{r multiple_end_port_states}
## multiple_end_port_states ----
# View(all_logbooks_db_data_2022_short_p_region_port_fields_all)

multiple_end_port_states <-
  all_logbooks_db_data_2022_short_p_region_port_fields_all |>
  # Select specific columns, retain distinct rows,
  # add a count end_port_state column for each combination of 'vessel_official_nbr' and 'permit_region'.
  dplyr::select(vessel_official_nbr,
                permit_region,
                end_port_state) |>
  dplyr::distinct() |>
  dplyr::add_count(vessel_official_nbr,
                   permit_region,
                   name = "end_port_state_cnt") |>
  # Filter for rows where the count of 'end_port_state' is greater than 1,
  # and arrange the data by 'vessel_official_nbr'.
  dplyr::filter(end_port_state_cnt > 1) |>
  dplyr::arrange(vessel_official_nbr)

multiple_end_port_states |>
  count_uniq_by_column()
# vessel_official_nbr 76

head(multiple_end_port_states)
```

#### How many vessels have multiple end port states 

```{r How many vessels have multiple end port states}
### How many vessels have multiple end port states ----
multiple_end_port_states |>
  select(vessel_official_nbr) |>
  distinct() |>
  count()
```

### by quarter 

```{r by quarter}
## by quarter ----
#
# all_logbooks_db_data_2022_short_p_region_short_all_port_names_by_vsl |>
#   filter(vessel_official_nbr == 1000042) |>
#   glimpse()
```

#### trips and quarter fields only 

```{r trips and quarter fields only}
### trips and quarter fields only ----

# Select specific columns using 'port_fields_all' function,
# remove columns starting with "notif",
# and retain columns related to trip start and end quarter information.

all_logbooks_db_data_2022_short_p_region_dates_trip_port_short <-
  all_logbooks_db_data_2022_short_p_region_dates_trip_port |>
  dplyr::select(
    port_fields_all(),
    -starts_with("notif"),
    c(trip_start_year_quarter,
      trip_start_quarter_num,
      trip_end_year_quarter,
      trip_end_quarter_num,)
  ) |>
  remove_empty_cols() |>
  dplyr::distinct()

dim(all_logbooks_db_data_2022_short_p_region_dates_trip_port_short)
# [1] 6639   15

count_uniq_by_column(all_logbooks_db_data_2022_short_p_region_dates_trip_port_short)
# vessel_official_nbr     1876
# permit_region              2
# start_port_name          531
# end_port_name            529
```

#### a quarter is the same, a port - diff 

```{r a quarter is the same, a port - diff}
### a quarter is the same, a port - diff ----

# test
all_logbooks_db_data_2022_short_p_region_dates_trip_port_short |>
  dplyr::filter(vessel_official_nbr == "1057052") |>
  dplyr::arrange(trip_start_quarter_num) |>
  dplyr::glimpse()

# Select columns for trip start, retain distinct rows.
start_ports_q_short <-
  all_logbooks_db_data_2022_short_p_region_dates_trip_port_short |>
  dplyr::select(vessel_official_nbr,
         permit_region,
         trip_start_year_quarter,
         start_port_name) |>
  dplyr::distinct()

# Select columns for trip end, retain distinct rows.
end_ports_q_short <-
  all_logbooks_db_data_2022_short_p_region_dates_trip_port_short |>
  dplyr::select(vessel_official_nbr,
         permit_region,
         trip_end_year_quarter,
         end_port_name) |>
  dplyr::distinct()

dim(start_ports_q_short)
# [1] 6317    4
dim(end_ports_q_short)
# [1] 5845    4

count_uniq_by_column(start_ports_q_short)
# vessel_official_nbr     1876
# start_port_name          531

count_uniq_by_column(end_ports_q_short)
# end_port_name          529
```

#### melt and decast the table 

```{r melt and decast the table}
### melt and decast the table ----

# Make one row per vessel
# In summary, the code transforms the data from a long to a wide format, spreading the values from the 'start_port_name' column across columns named by 'trip_start_year_quarter', and aggregating multiple values into a comma-separated string.

# The pivot_wider() function from the tidyr package is used to reshape the data.
# It takes the 'vessel_official_nbr' column as the identifier columns,
# and then it spreads the values from the 'trip_start_year_quarter' column into
# separate columns, with the corresponding values being taken from the
# 'start_port_name' column.
# The values_fn parameter is specified to define how to handle multiple
# values that may exist for a combination of 'vessel_official_nbr' and
# 'trip_start_year_quarter'. In this case, unique values are sorted and
# concatenated into a comma-separated string.

# Define a function 'each_quarter_a_col' that takes a data frame 'my_df' and an argument 'start_or_end' with a default value "start".
each_quarter_a_col <-
  function(my_df,
           start_or_end = "start") {

    # Generate field names dynamically using 'stringr::str_glue'.
    quarter_field_name <-
      stringr::str_glue("trip_{start_or_end}_year_quarter")
    port_field_name <-
      stringr::str_glue("{start_or_end}_port_name")

    # Reshape the data frame 'my_df' by widening it based on unique combinations of vessel, region, and quarter.
    ports_q_short_wider <-
      my_df |>
      tidyr::pivot_wider(
        id_cols = c(vessel_official_nbr, permit_region),
        names_from = !!sym(quarter_field_name),
        values_from = !!sym(port_field_name),
        values_fn = ~ paste(unique(sort(.x)), collapse = ",")
      )

    # Return the widened data frame.
    return(ports_q_short_wider)
  }
```

Explanation:

1. The function takes a data frame (`my_df`) and an optional argument (`start_or_end`) indicating whether it's for trip start or end.

2. Dynamically generate field names for the quarter and port based on the input.

3. Use the `pivot_wider` function to reshape the data frame by creating new columns for each unique combination of vessel, region, and quarter.

4. The `values_fn` argument ensures that duplicate values are concatenated and sorted within each cell.

5. Return the resulting widened data frame.

#### use the function for trip start and end ports separately 

```{r use the function for trip start and end ports separately}
### use the function for trip start and end ports separately ----

# Create a new list 'ports_q_short_wider_list' by applying a series of operations to each element
# of the provided list, where each element is a pair of a data frame and a character indicating start or end.
ports_q_short_wider_list <-
  list(c(start_ports_q_short, "start"),
       c(end_ports_q_short, "end")) |>
  purrr::map(\(one_df_l) {
    # Extract the data frame and the character indicating start or end.
    df_len <- length(one_df_l)
    my_df <-
      one_df_l[1:df_len - 1] |>
      as.data.frame()
    my_col_name <- one_df_l[[df_len]]
    # Apply the 'each_quarter_a_col' function to reshape the data frame based on quarters.
    each_quarter_a_col(my_df, my_col_name)
  })
```

Explanation:

1. Create a list where each element is a pair containing a data frame ("start_ports_q_short" or "end_ports_q_short") and a character ("start" or "end").

2. Use the "map" function to apply a series of operations to each element of the list.

3. Extract the data frame and the character from each pair.

4. Convert the extracted data frame to a standard data frame using "as.data.frame()".

5. Apply the "each_quarter_a_col" function to reshape the data frame based on quarters, using the extracted character as an argument.

6. The resulting list, "ports_q_short_wider_list", contains data frames widened based on quarters for both start and end ports.


```{r}
# glimpse(ports_q_short_wider_list)


# start_ports_q_short_wider <-
#   start_ports_q_short |>
#   pivot_wider(
#     id_cols = c(vessel_official_nbr, permit_region),
#     names_from = trip_start_year_quarter,
#     values_from = start_port_name,
#     values_fn = ~ paste(unique(sort(.x)), collapse = ",")
#   )

head(ports_q_short_wider_list[[1]])
```

#### add column for the same or diff 

```{r add column for the same or diff}
### add column for the same or diff ----
```

##### create an auxiliary function 

```{r create an auxiliary function}
#### create an auxiliary function ----
```

It starts by using the rowwise() function to apply subsequent operations
to each row individually, ensuring that calculations are row-wise.

The mutate() function is then used to create a new column 'same'.

This column is assigned the result of a logical comparison:

It checks if the number of distinct values in all columns that start with '2022'
is equal to 1, indicating that all these columns have the same value for a given row.

The ungroup() function is then applied to remove the grouping structure introduced by rowwise().

rlang::\`:=\` used inside mutate() to work with dynamic field names (!!ports_num_field_name), e.g. a variable name instead of a string


```{r}
make_ports_q_short_wider_diff <-
  function(my_df,
           start_or_end = "start") {

    ports_num_field_name <-
      stringr::str_glue("all_{start_or_end}_ports_num")

    ports_field_name <-
      stringr::str_glue("all_{start_or_end}_ports")

    ports_q_short_wider_diff <-
      my_df |>
      dplyr::rowwise() |>
      dplyr::mutate(!!ports_num_field_name :=
               dplyr::n_distinct(unlist(dplyr::across(
                 dplyr::starts_with('2022')
               ))),
             !!ports_field_name :=
               list(paste(unique(sort(
                 unlist(dplyr::across(dplyr::starts_with('2022')))
               )),
               sep = ","))) |>
      dplyr::mutate(same =
                      dplyr::n_distinct(unlist(dplyr::across(
        dplyr::starts_with('2022'),
        ~ as.character(.x)
      ))) == 1) |>
      dplyr::ungroup()

    return(ports_q_short_wider_diff)
  }

# View(ports_q_short_wider_list)
```

##### use the auxiliary function 

```{r use the auxiliary function}
#### use the auxiliary function ----
tic("ports_q_short_wider_list_diff")

# Create a new list 'ports_q_short_wider_list_diff' by applying a series of operations to each element
# of the provided list, where each element is a pair of a data frame and a character indicating start or end.
ports_q_short_wider_list_diff <-
  list(c(ports_q_short_wider_list[[1]], "start"),
       c(ports_q_short_wider_list[[2]], "end")) |>
  purrr::map(\(one_df_l) {
    # Extract the data frame and the character indicating start or end.
    df_len <- length(one_df_l)
    my_df_names <- names(one_df_l)[1:df_len - 1]
    my_df <- one_df_l[1:df_len - 1] |>
      as.data.frame()
    names(my_df) <- my_df_names
    my_col_name <- one_df_l[[df_len]]
    # Apply the 'make_ports_q_short_wider_diff' function to calculate the differences between quarters.
    make_ports_q_short_wider_diff(my_df, my_col_name)
  })
```

Explanation:

1. Create a list where each element is a pair containing a data frame from "ports_q_short_wider_list" and a character ("start" or "end").

2. Use the "map" function to apply a series of operations to each element of the list.

3. Extract the data frame and the character from each pair.

4. Extract the column names of the data frame and assign them to "my_df_names".

5. Convert the extracted data frame to a standard data frame using "as.data.frame()" and set its column names.

6. Apply the "make_ports_q_short_wider_diff" function to calculate the differences between quarters.

7. The resulting list, "ports_q_short_wider_list_diff", contains data frames with differences between quarters for both start and end ports.


```{r}
toc()
# ports_q_short_wider_list_diff: 9.93 sec elapsed

# diffdf::diffdf(start_ports_q_short_wider_diff, ports_q_short_wider_list_diff[[1]])
```

##### check the result 

```{r check the result}
#### check the result ----
ports_q_short_wider_list_diff[[1]] |>
  dplyr::filter(vessel_official_nbr == "1171256") |>
  dplyr::glimpse()
# $ all_start_ports_num <int> 3
# $ all_start_ports     <list> <"BARNEGAT,MORRISON'S MARINA AND  SHIPS STORE", "Mâ€¦
# $ same                <lgl> FALSE

names(ports_q_short_wider_list_diff) <-
  c("start", "end")

ports_q_short_wider_list_diff |>
  purrr::map(count_uniq_by_column)
# start:
# vessel_official_nbr 1876
# 2022 Q3              484
# 2022 Q4              356
# 2022 Q2              488
# 2022 Q1              290
# all_start_ports      697

# end:
# vessel_official_nbr 1876
# permit_region          2
# 2022 Q3              497
# 2022 Q4              360
# 2022 Q2              497
# 2022 Q1              290
# 2023 Q1                7
# 2023 Q2                3
# 2018 Q2                2
# 2021 Q2                3
# 2020 Q4                2
# all_end_ports        701
```

#### count same or diff trip start or end 

```{r count same or diff trip start or end}
### count same or diff trip start or end ----

ports_q_short_wider_list_diff_cnts <-
  ports_q_short_wider_list_diff |>
  purrr::map(\(one_df) {
    one_df |>
      dplyr::select(vessel_official_nbr, same) |>
      dplyr::count(same)
  })
# start
# 1 FALSE  1421 (incl. NAs)
# 2 TRUE    455

# end
# 1 FALSE  1391 (incl. NAs)
# 2 TRUE    485

# use pander for .qmd
pander(ports_q_short_wider_list_diff_cnts)
```

#### count same or diff by permit_region and trip start or end 

```{r count same or diff by permit_region and trip start or end}
### count same or diff by permit_region and trip start or end ----
ports_q_short_wider_list_diff_cnt_p_r <-
  ports_q_short_wider_list_diff |>
  purrr::map(\(one_df) {
    one_df |>
      dplyr::count(permit_region, same)
  })

# use pander for .qmd
pander(ports_q_short_wider_list_diff_cnt_p_r)

# start
#   permit_region same      n
#   <chr>         <lgl> <int>
# 1 gom_and_dual  FALSE   569
# 2 gom_and_dual  TRUE    222
# 3 sa_only       FALSE   852
# 4 sa_only       TRUE    233

# end
#   permit_region same      n
#   <chr>         <lgl> <int>
# 1 gom_and_dual  FALSE   561
# 2 gom_and_dual  TRUE    230
# 3 sa_only       FALSE   830
# 4 sa_only       TRUE    255
```

## Quantify the # of vessels who fish in both the gulf and S Atl.  

```{r Quantify the # of vessels who fish in both the gulf and S Atl.}
# Quantify the # of vessels who fish in both the gulf and S Atl.  ----
```

### add a gom vs sa marker to ports 

```{r add a gom vs sa marker to ports}
## add a gom vs sa marker to ports ----
```

#### shorten all_logbooks_db_data_2022_short_p_region 

```{r shorten all_logbooks_db_data_2022_short_p_region}
### shorten all_logbooks_db_data_2022_short_p_region ----
all_logbooks_db_data_2022_short_p_region_port_region <-
  all_logbooks_db_data_2022_short_p_region |>
  dplyr::select(
      vessel_id,
      vessel_official_nbr,
      start_port,
      start_port_name,
      start_port_county,
      start_port_state,
      end_port,
      end_port_name,
      end_port_county,
      end_port_state,
      permit_region
    ) |>
  remove_empty_cols() |>
  dplyr::distinct()

# dim(all_logbooks_db_data_2022_short_p_region_port_region)
# [1] 3011   11
```

#### add full state name 

```{r add full state name}
### add full state name ----
all_logbooks_db_data_2022_short_p_region_port_region |>
  dplyr::select(start_port_state) |>
  dplyr::distinct() |>
  head(2)
# "FL", "DE"

names(state.abb) <- state.name
names(state.name) <- state.abb

my_state_name[tolower("FL")]
# "Florida"
```

### add a start_port_reg column 

```{r add a start_port_reg column}
## add a start_port_reg column ----

all_logbooks_db_data_2022_short_p_region_port_states <-
  all_logbooks_db_data_2022_short_p_region_port_region |>
  # Add columns for the state names corresponding to start and end ports.
  dplyr::mutate(
    start_port_state_name = my_state_name[tolower(start_port_state)],
    end_port_state_name   = my_state_name[tolower(end_port_state)]
  ) |>
  # Add a column 'start_port_reg' based on conditions using 'case_when'.
  dplyr::mutate(
    start_port_reg =
      dplyr::case_when(
        tolower(start_port_state_name) %in% tolower(sa_council_states) ~
          "sa_council_state",
        tolower(end_port_state_name) %in% tolower(east_coat_states$gom) ~
          "gom_state",
        .default = "sa_state"
      )
    # Additional commented-out line for potential future use.
    # diff_reg = case_when(!start_port_state == end_port_state)
  )
```

Explanation:

1. Create a new data frame "all_logbooks_db_data_2022_short_p_region_port_states" by applying operations to "all_logbooks_db_data_2022_short_p_region_port_region".

2. Add columns for the state names corresponding to start and end ports.

3. Add a new column "start_port_reg" based on conditions using "case_when":

   - If the start port state is in "sa_council_states", set it to "sa_council_state".

   - If the end port state is in "east_coat_states$gom", set it to "gom_state".

   - For other cases, set it to "sa_state".

   - Additional commented-out line ("diff_reg") for potential future use.


```{r}
head(all_logbooks_db_data_2022_short_p_region_port_states)
# [1] 3011   14
```

#### if FL divide by county 

```{r if FL divide by county}
### if FL divide by county ----
```

Add a new column "start_port_fl_reg" based on conditions using "case_when":

If the start port state name is "florida" and the start port county is in "fl_counties$gom", set it to "gom_county".

For other cases, set it to "sa_county".


```{r}
all_logbooks_db_data_2022_short_p_region_port_states_fl_reg <-
  all_logbooks_db_data_2022_short_p_region_port_states |>
  dplyr::mutate(
    start_port_fl_reg =
      dplyr::case_when(
        tolower(start_port_state_name) == "florida" &
          tolower(start_port_county) %in% tolower(fl_counties$gom) ~
          "gom_county",
        .default = "sa_county"
      )
  )

all_logbooks_db_data_2022_short_p_region_port_states_fl_reg |>
  filter(start_port_fl_reg == "gom_county") |>
  dim()
# [1] 844  15

dplyr::glimpse(all_logbooks_db_data_2022_short_p_region_port_states_fl_reg)
```

#### create one_port_marker 

```{r create one_port_marker}
### create one_port_marker ----
```

Combine all previous region markers into one column

If Monroe, FL divide by vessel permit_region


```{r}
all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start <-
  all_logbooks_db_data_2022_short_p_region_port_states_fl_reg |>
  dplyr::mutate(
    one_start_port_marker =
      dplyr::case_when(
        start_port_county == "MONROE" &
          permit_region == "gom_and_dual" ~
          "gom",
        start_port_county == "MONROE" &
          permit_region == "sa_only" ~
          "sa",
        start_port_state == "FL" &
          start_port_fl_reg == "gom_county" ~
          "gom",
        start_port_state == "FL" &
          start_port_fl_reg == "sa_county" ~
          "sa",
        start_port_reg %in% c("gom_council_state",
                              "gom_state") ~
          "gom",
        start_port_reg %in% c("sa_council_state",
                              "sa_state") ~
          "sa",
        .default = NA
      )
  )
```

Explanation:

1. Create a new data frame "all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start" by applying operations to "all_logbooks_db_data_2022_short_p_region_port_states_fl_reg".

2. Add a new column "one_start_port_marker" based on conditions using "case_when":

   - If the start port county is "MONROE" and the permit region is "gom_and_dual", set it to "gom".

   - If the start port county is "MONROE" and the permit region is "sa_only", set it to "sa".

   - If the start port state is "FL" and the start port FL region is "gom_county", set it to "gom".

   - If the start port state is "FL" and the start port FL region is "sa_county", set it to "sa".

   - If the start port region is "gom_council_state" or "gom_state", set it to "gom".

   - If the start port region is "sa_council_state" or "sa_state", set it to "sa".
   - For other cases, set it to NA.


```{r}
glimpse(all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start)
# [1] 3011   16
```

##### check if all start ports have a permit region 

```{r check if all start ports have a permit region}
#### check if all start ports have a permit region ----
all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start |>
  dplyr::filter(is.na(one_start_port_marker)) |>
  # select(start_port_reg) |>
  # distinct() |>
  dim()
# 0 OK

all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start |>
    dplyr::filter(one_start_port_marker == "gom") |>
    dplyr::select(vessel_official_nbr, contains("start")) |>
    dplyr::distinct() |>
    dplyr::glimpse()
```

#### Count vessels having both sa and gom one_start_port_markers to find the num of vessels who fish in both the Gulf and S Atl 

```{r Count vessels having both sa and gom one_start_port_markers to find the num of vessels who fish in both the Gulf and S Atl}
### Count vessels having both sa and gom one_start_port_markers to find the num of vessels who fish in both the Gulf and S Atl ----
```

##### shorten all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start 

```{r shorten all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start}
#### shorten all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start ----
all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start_short <-
  all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start |>
  dplyr::select(
    vessel_id,
    vessel_official_nbr,
    start_port,
    start_port_name,
    start_port_county,
    start_port_state,
    end_port,
    end_port_name,
    end_port_county,
    end_port_state,
    permit_region,
    start_port_state_name,
    end_port_state_name,
    one_start_port_marker
  ) |>
  dplyr::distinct()

count_uniq_by_column(all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start_short)
# [1] 3011   14
# vessel_official_nbr   1876
# start_port             536
# start_port_name        531
```

##### Count vessels with each GOM or SA trip start port region marker 

```{r Count vessels with each GOM or SA trip start port region marker}
#### Count vessels with each GOM or SA trip start port region marker ----
```

(the occurrences of each unique value in the "one_start_port_marker" column).


```{r}
all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start_short |>
  dplyr::select(vessel_official_nbr, one_start_port_marker) |>
  dplyr::distinct() |>
  dplyr::count(one_start_port_marker)
# 1                   gom 1000
# 2                    sa 1029
```

##### Count vessels with each GOM or SA trip start port region marker per vessel permit_region 

```{r Count vessels with each GOM or SA trip start port region marker per vessel permit_region}
#### Count vessels with each GOM or SA trip start port region marker per vessel permit_region ----

all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start_short |>
  dplyr::select(vessel_official_nbr,
         permit_region,
         one_start_port_marker) |>
  dplyr::distinct() |>
  dplyr::count(permit_region, one_start_port_marker)
# 1  gom_and_dual                   gom  784
# 2  gom_and_dual                    sa   16
# 3       sa_only                   gom  216
# 4       sa_only                    sa 1013
```

### Trip start ports are in both regions 

```{r Trip start ports are in both regions}
## Trip start ports are in both regions ----
select_vessel_mark_start <-
  c("vessel_official_nbr",
    "one_start_port_marker")

start_ports_region_cnt <-
  all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start_short |>
  dplyr::select(dplyr::all_of(select_vessel_mark_start)) |>
  dplyr::distinct() |>
  dplyr::group_by(vessel_official_nbr) |>
  dplyr::mutate(
    vessel_one_start_port_marker_num =
      dplyr::n_distinct(one_start_port_marker,
                        na.rm = TRUE)
  ) |>
  ungroup()
```

Explanation:

1. Create a new data frame "start_ports_region_cnt" by applying operations to "all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start_short".

2. Select columns based on "select_vessel_mark_start".

3. Retain distinct rows.

4. Group the data by "vessel_official_nbr".

5. Add a new column "vessel_one_start_port_marker_num" counting the distinct values of "one_start_port_marker" for each vessel.

6. Ungroup the data.

###### check start_ports_region_cnt 

```{r check start_ports_region_cnt}
##### check start_ports_region_cnt ----
# [1] 2029    3

count_uniq_by_column(start_ports_region_cnt)
# vessel_official_nbr              1876
# one_start_port_marker               2
# vessel_one_start_port_marker_num    2

start_ports_region_cnt |>
  dplyr::filter(vessel_official_nbr == "1021879")
```

##### How many vessels have start port in one or in both regions 

```{r How many vessels have start port in one or in both regions}
#### How many vessels have start port in one or in both regions ----
start_ports_region_cnt |>
  count(vessel_one_start_port_marker_num)
```

#### Trip start ports are in both regions count by vessel permit 

```{r Trip start ports are in both regions count by vessel permit}
### Trip start ports are in both regions count by vessel permit ----
start_ports_region_cnt_by_permit_r <-
  all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start_short |>
  dplyr::select(dplyr::all_of(select_vessel_mark_start),
                permit_region) |>
  dplyr::distinct() |>
  dplyr::group_by(vessel_official_nbr, permit_region) |>
  dplyr::mutate(vessel_one_start_port_marker_num =
           dplyr::n_distinct(one_start_port_marker,
                      na.rm = TRUE)) |>
  dplyr::ungroup()
```

Explanation:

1. Create a new data frame "start_ports_region_cnt_by_permit_r" by applying operations to "all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start_short".

2. Select columns based on "select_vessel_mark_start" and "permit_region".

3. Retain distinct rows.

4. Group the data by "vessel_official_nbr" and "permit_region".

5. Add a new column "vessel_one_start_port_marker_num" counting the distinct values of "one_start_port_marker" for each vessel within each permit region.

6. Ungroup the data.

##### check start_ports_region_cnt_by_permit_r 

```{r check start_ports_region_cnt_by_permit_r}
#### check start_ports_region_cnt_by_permit_r ----
start_ports_region_cnt_by_permit_r |>
  # filter(vessel_one_start_port_marker_num > 1) |>
  dplyr::filter(vessel_official_nbr == "FL6069PT") |>
  dplyr::glimpse()
```

##### Count multiple starts by permit_region 

```{r Count multiple starts by permit_region}
#### Count multiple starts by permit_region ----
start_ports_region_cnt_by_permit_r |>
  # glimpse()
  dplyr::select(
    vessel_official_nbr,
    permit_region,
    vessel_one_start_port_marker_num
  ) |>
  dplyr::distinct() |>
# vessel_official_nbr              1876
  dplyr::count(permit_region,
        multi_start = vessel_one_start_port_marker_num > 1)
#   count(wt = n)
# 1  1876

#   permit_region multi_start     n
#   <chr>         <lgl>       <int>
# 1 gom_and_dual  FALSE         782
# 2 gom_and_dual  TRUE            9
# 3 sa_only       FALSE         941
# 4 sa_only       TRUE          144
```

## look at permit home port vs where they take trip 

```{r look at permit home port vs where they take trip}
# look at permit home port vs where they take trip ----
```

### prepare home_port data 

```{r prepare home_port data}
## prepare home_port data ----
# all_get_db_data_result_l |>
#   print_df_names()

# all_get_db_data_result_l$vessels_permits |>
  # print_df_names()

vessel_permit_port_info <-
  all_get_db_data_result_l$vessels_permits |>
  # active permits in 2022
  dplyr::filter(
    LAST_EXPIRATION_DATE > "2022-12-31" |
      END_DATE > "2022-12-31" |
      EXPIRATION_DATE > "2022-12-31"
  )

count_uniq_by_column(vessel_permit_port_info)
# with exp_date:
# [1] 12238     8
# SERO_OFFICIAL_NUMBER  5220
# SERO_HOME_PORT_CITY    809
```

#### add permit and vessel info 

```{r add permit and vessel info}
### add permit and vessel info ----
# should do here, before the join, bc if there are empty rows after merge sa_only is wrongly assigned

vessel_permit_port_info_perm_reg <-
  vessel_permit_port_info |>
  dplyr::group_by(VESSEL_VESSEL_ID) |>
  dplyr::mutate(all_permits = toString(unique(sort(TOP)))) |>
  separate_permits_into_3_groups(permit_group_field_name = "all_permits") |>
  select(
    PERMIT_VESSEL_ID,
    VESSEL_VESSEL_ID,
    # PORT_CODE, mostly empty
    permit_sa_gom,
    SERO_HOME_PORT_CITY,
    SERO_HOME_PORT_COUNTY,
    SERO_HOME_PORT_STATE,
    SERO_OFFICIAL_NUMBER
  ) |>
  dplyr::ungroup() |>
  remove_empty_cols() |>
  dplyr::distinct()

count_uniq_by_column(vessel_permit_port_info_perm_reg)
# [1] 5220    7
# VESSEL_VESSEL_ID      5220

vessel_permit_port_info_perm_reg |>
  dplyr::filter(permit_sa_gom == "sa_only") |>
  dplyr::distinct() |>
  dplyr::glimpse()
```

NB. 1. There is incorrect home port info (city/county/state).

2. permit information is some times different from that in logbooks (trips)

3. In logbooks there are trip end dates in weird years

2018 Q2                2
2021 Q2                3
2020 Q4                2
### add vessel_permit information to trip (logbook) information 

```{r add vessel_permit information to trip (logbook) information}
## add vessel_permit information to trip (logbook) information ----
# print_df_names(all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start)

join_vessel_and_trip <-
  dplyr::left_join(
    all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start_short,
    vessel_permit_port_info_perm_reg,
    dplyr::join_by(vessel_id == VESSEL_VESSEL_ID)
  )

dplyr::glimpse(join_vessel_and_trip)
# [1] 3011   20

# vessel_id             1876
# vessel_official_nbr   1876
# permit_sa_gom            4
# SERO_OFFICIAL_NUMBER  1785

dim(all_logbooks_db_data_2022_short_p_region_port_states_fl_reg_start_short)
# [1] 3011   14
```

#### check permit_regions 

```{r check permit_regions}
### check permit_regions ----
join_vessel_and_trip |>
  dplyr::filter(!permit_region == permit_sa_gom) |>
  dplyr::select(permit_region, permit_sa_gom) |>
  dplyr::distinct() |>
  dplyr::arrange(permit_region)
#   permit_region permit_sa_gom
# 1  gom_and_dual          dual
# 2  gom_and_dual      gom_only

# 3  gom_and_dual       sa_only
# 4       sa_only          dual
# 5       sa_only      gom_only
```

TODO: compare regions, why diff. Permits in logbooks (trips) and in permit data are different


```{r}
join_vessel_and_trip |>
  dplyr::filter(permit_region == "gom_and_dual" &
                  permit_sa_gom == "sa_only") |>
  dplyr::glimpse()
# 6

join_vessel_and_trip |>
  dplyr::filter(permit_region == "sa_only" &
                  permit_sa_gom == "dual") |>
  dim()
# 40

join_vessel_and_trip |>
  dplyr::filter(permit_region == "sa_only" &
           permit_sa_gom == "gom_only") |>
  dplyr::glimpse()
# FL1921PM
# PIMS:
# Home port
# PENSACOLA, FL
# dual

# vessel_id, vessel_official_nbr, start_port, start_port_name, start_port_county, start_port_state, end_port, end_port_name, end_port_county, end_port_state, permit_region, start_port_state_name, end_port_state_name, one_start_port_marker, PERMIT_VESSEL_ID, permit_sa_gom, SERO_HOME_PORT_CITY, SERO_HOME_PORT_COUNTY, SERO_HOME_PORT_STATE, SERO_OFFICIAL_NUMBER
```

#### add columns for different start and home port names, counties and states 

```{r add columns for different start and home port names, counties and states}
### add columns for different start and home port names, counties and states ----
tic("join_vessel_and_trip_port_diff")
join_vessel_and_trip_port_diff <-
  join_vessel_and_trip |>
  dplyr::group_by(vessel_official_nbr) |>
  dplyr::mutate(
    diff_start_port_state =
      dplyr::case_when(
        !tolower(start_port_state) == tolower(SERO_HOME_PORT_STATE) ~
          "yes",
        .default = "no"
      ),
    diff_start_port_county =
      dplyr::case_when(
        !tolower(start_port_county) == tolower(SERO_HOME_PORT_COUNTY) ~
          "yes",
        .default = "no"
      ),
    diff_start_port_name_or_city =
      dplyr::case_when(
        !tolower(start_port_name) == tolower(SERO_HOME_PORT_CITY) ~
          "yes",
        .default = "no"
      )
  ) |>
  mutate(
    diff_end_port_state =
      dplyr::case_when(
        !tolower(end_port_state) == tolower(SERO_HOME_PORT_STATE) ~
          "yes",
        .default = "no"
      ),
    diff_end_port_county =
      dplyr::case_when(
        !tolower(end_port_county) == tolower(SERO_HOME_PORT_COUNTY) ~
          "yes",
        .default = "no"
      ),
    diff_end_port_name_or_city =
      dplyr::case_when(
        !tolower(end_port_name) == tolower(SERO_HOME_PORT_CITY) ~
          "yes",
        .default = "no"
      )
  ) |>
  dplyr::ungroup()
toc()
# join_vessel_and_trip_port_diff: 1.74 sec elapsed
```

Explanation:

1. Start measuring the execution time using the `tic()` function.

2. Create a new data frame "join_vessel_and_trip_port_diff" by applying operations to "join_vessel_and_trip".

3. Group the data by "vessel_official_nbr".

4. Add columns indicating differences between home port and trip start/end ports for both start and end ports.

5. Ungroup the data.

6. Stop measuring the execution time using the `toc()` function and display the elapsed time.


```{r}
join_vessel_and_trip_port_diff |>
  dplyr::select(vessel_official_nbr,
         dplyr::starts_with("diff")) |>
  dplyr::distinct() |>
  dim()
# [1] 2591    7
```

##### shorten join_vessel_and_trip_port_diff 

```{r shorten join_vessel_and_trip_port_diff}
#### shorten join_vessel_and_trip_port_diff ----
join_vessel_and_trip_port_diff_short <-
  join_vessel_and_trip_port_diff |>
  dplyr::select(vessel_official_nbr,
                permit_region,
                dplyr::starts_with("diff")) |>
  dplyr::distinct()

glimpse(join_vessel_and_trip_port_diff_short)
```

### count vessel number with different start_port_state and home_port_state 

```{r count vessel number with different start_port_state and home_port_state}
## count vessel number with different start_port_state and home_port_state ----
```

#### check for one column 

```{r check for one column}
### check for one column ----
join_vessel_and_trip_port_diff_short |>
  dplyr::count(diff_start_port_state)
# 1 no                     2501
# 2 yes                      90
```

#### make combinations of column names 

```{r make combinations of column names}
### make combinations of column names ----
my_col_names <- names(join_vessel_and_trip_port_diff_short)

my_col_names

combs1 <-
  utils::combn(my_col_names, 2) |>
  as.data.frame()

str(combs1)
# 'data.frame':	2 obs. of  28 variables:
#  $ V1 : chr  "vessel_official_nbr" "permit_region"
#  $ V2 : chr  "vessel_official_nbr" "diff_start_port_state"
#  $ V3 : chr  "vessel_official_nbr" "diff_start_port_county"
```

#### keep only combinations of vessel_official_nbr with another column 

```{r keep only combinations of vessel_official_nbr with another column}
### keep only combinations of vessel_official_nbr with another column ----
combs1_short <-
  combs1[1:ncol(join_vessel_and_trip_port_diff_short) - 1]

combs1_short
```

#### count vessels with different trip and home port info, using each pair of names 

```{r count vessels with different trip and home port info, using each pair of names}
### count vessels with different trip and home port info, using each pair of names ----
combs1_short_cnts <-
  combs1_short |>
  purrr::map(\(curr_col_names) {
    # browser()
    join_vessel_and_trip_port_diff_short |>
      dplyr::select(paste(curr_col_names, sep = ",")) |>
      dplyr::count(!!sym(curr_col_names[[2]]))
  })
```

This code uses the "map" function from the purrr package to iterate over each element (curr_col_names) in the combs1_short list. Within the map function:

1. The "join_vessel_and_trip_port_diff_short" data frame is piped into the "select" function, where columns specified by "curr_col_names" are selected using "paste" and separated by commas.

2. The "count" function is then applied to the selected data frame. The column to count is specified using "!!sym(curr_col_names[[2]])", where "sym" is used to convert the column name to a symbol for evaluation.

The result is a list of data frames, where each data frame contains the counts of occurrences of vessel ids for the second column in "curr_col_names".

##### Show vessel num with different trip and home port info, using each pair of names 

```{r Show vessel num with different trip and home port info, using each pair of names}
# |> results="hide"

#### Show vessel num with different trip and home port info, using each pair of names ----

# use pander for .qmd
pander(combs1_short_cnts)
```

### Repeat the same with permit region 

```{r Repeat the same with permit region}
## Repeat the same with permit region ----
join_vessel_and_trip_port_diff_short_perm <-
  join_vessel_and_trip_port_diff |>
  dplyr::select(vessel_official_nbr,
         permit_region,
         dplyr::starts_with("diff")) |>
  dplyr::distinct()

join_vessel_and_trip_port_diff_short_perm |>
  dplyr::count(diff_start_port_state)
# 1 no                     2501
# 2 yes                      90

my_col_names <- names(join_vessel_and_trip_port_diff_short_perm)

combs2 <-
  utils::combn(my_col_names, 3) |>
  as.data.frame()
```

How many column names have "diff" in it?


```{r}
dif_cols_num <-
  grep("diff", my_col_names) |>  length()

combs2_short <-
  combs2[1:dif_cols_num]

# View(combs2_short)
```

#### count vessels with different trip and home port info per permit_region, using each set of names 

```{r count vessels with different trip and home port info per permit_region, using each set of names}
### count vessels with different trip and home port info per permit_region, using each set of names ----
combs2_short_cnts <-
  combs2_short |>

  # Use 'map' to apply a function to each element of 'combs2_short'
  purrr::map(\(curr_col_names) {

    # Use 'join_vessel_and_trip_port_diff_short' as the data source
    join_vessel_and_trip_port_diff_short |>

      # Select columns specified by 'curr_col_names' and separate them with ","
      dplyr::select(paste(curr_col_names, sep = ",")) |>

      # Count occurrences of unique combinations of the second and third columns
      dplyr::count(!!sym(curr_col_names[[2]]),
            !!sym(curr_col_names[[3]]))
  })
```

##### Show vessel num with different trip and home port info per permit_region using each set of names 

```{r Show vessel num with different trip and home port info per permit_region using each set of names}
# |> results="hide"
#### Show vessel num with different trip and home port info per permit_region using each set of names ----
# use pander for .qmd
pander(combs2_short_cnts)
```

# Results

Analyzing movement patterns of vessels:

1. How many SEFHIER vessels start at a different location than they end

2. How many vessels have variable landing locations

(i.e., in the winter they are in one state while in the summer they fish in another)

3. Quantify the # of vessels who fish in both the gulf and S Atl.

4. Look at permit home port vs where they take trip

## How many SEFHIER vessels start at a different location than they end


```{r}
#
# !start_port_name == end_port_name
#
```
```{r How many SEFHIER vessels start at a different location than they end}
```


## How many vessels have variable landing locations
 (i.e., in the winter they are in one state while in the summer they fish in another)

### How many vessels have multiple end ports


```{r How many vessels have multiple end ports}
```


### How many vessels have multiple end port states


```{r How many vessels have multiple end port states}
```


### How many vessels have same (or diff) trip start or end in all quarters of 2022

```{r count same or diff trip start or end}
```


### How many vessels have same (or diff) trip start or end in all quarters of 2022 by permit region

```{r count same or diff by permit_region and trip start or end}
```


## Quantify the number of vessels who fish in both the Gulf and S Atl
By counting start ports.


```{r How many vessels have start port in one or in both regions}
```

### The same (start in both Gulf and S Atl) by a vessel permit region


```{r Count multiple starts by permit_region}
```

## Look at permit home port vs where they take trip
Each column name starting with "diff_" represents the difference between trip ports and home port names or their respective counties and states.


```{r Show vessel num with different trip and home port info, using each pair of names}
```

### The same (home port vs. trip ports) by a vessel permit region


```{r Show vessel num with different trip and home port info per permit_region using each set of names}
```

