# change dir name!
curent_project_name <- readline(prompt = "Print you project name: ")
# egregious_violators
curent_file_name_no_ext <- readline(prompt = "Print you file name: ")

# In the input .R file:
# add "#' " in front of comments to be shown as text
# and #' as the last line of the visible comments
# add #' {{< include FILE_NAME.qmd >}} instead of source

# In the output .qmd:
# *) comment out "source" as needed (or turn on comment_out_sources to suppress all)
# *) merge "# save setup chunk options to use later" with the next chunk
# *) add
# |>
#   knitr::kable(caption = "My Caption")
# for pretty tables

# setup ----
# source("~/R_code_github/useful_functions_module.r")
library(auxfunctions)
my_paths <- set_work_dir()

dir_to_comb <-
  file.path(my_paths$git_r,
            curent_project_name)

dir.exists(dir_to_comb)

file_name <- curent_file_name_no_ext
  # curent_project_name
file_ext <- c("R", "Rmd", "qmd")

# Create a list of file paths for each file extension.
file_paths <-
  purrr::map(file_ext,
      ~ file.path(dir_to_comb,
                  paste0(file_name, ".", .x)))

# Set the names of the list elements to 'file_ext'.
names(file_paths) <- file_ext

# prepare all pieces ----
## read the main file content ----
flat_file_r_text <-
  readLines(file_paths$R)

head(flat_file_r_text)

## Add headers to the flat file to be converted by knitr ----
# In this code, 'flat_file_r_text' is generated by modifying the text content read from the file specified by 'r_file_name'. The 'gsub' function is used to replace specific patterns in the text:
#
# It searches for lines that start with one or more '#' symbols followed by a space, captures the content after that, and then captures a line with "----" at the end.
# It replaces this pattern with a modified format, adding "#'" at the beginning of the first line for headers,
# and copying the pattern on the second line to keep comments in place.
# This transformation is used to adapt R script file to an R Markdown format by converting header lines to Roxygen-style comments.
#

# In this code, 'flat_file_r_text' is modified using the 'gsub' function to replace specific patterns in the text. The pattern being searched for is defined using a regular expression.
# It automatically makes chunk titles

unify_comments <-
  function(flat_file_r_text) {
    flat_file_r_text <-
      gsub(" ====",
           " ----",
           flat_file_r_text)
    return(flat_file_r_text)
  }

make_chunk_titles_from_comments <-
  function(flat_file_r_text) {

    pattern_to_add_md_headers <- "#' \\1\\2"
    pattern_to_add_md_chunk_labels <- "#+ \\2"
    pattern_to_repeat_the_original <- "\\1\\2\\3"

    flat_file_r_text <-
      unify_comments(flat_file_r_text)

    flat_file_r_text <-
      gsub(
        "^(#+ )(.+)(----)",
        paste(
          pattern_to_add_md_headers,
          pattern_to_add_md_chunk_labels,
          pattern_to_repeat_the_original,
          sep = "\\\n"
        ),
        flat_file_r_text
      )

    return(flat_file_r_text)
  }

flat_file_r_text <-
  make_chunk_titles_from_comments(flat_file_r_text)

# It searches for lines starting with "#+" followed by a space and captures the content after that.
# It captures a single quote or a slash.
# It captures more content.
# It captures a newline character.
# Remove all "odd" characters from chunk titles for knitr to work with.
# repeat twice
# 
clean_chunk_titles <-
  function(flat_file_r_text) {
    # browser()
    flat_file_r_text <-
      flat_file_r_text |>
      str_replace_all("(#\\+[^#]*)[^A-z0-9#+ ]+([^#]+)", "\\1\\2")
    if (any(str_detect(flat_file_r_text,
                       "#\\+[^#]*[^A-z0-9#+ ]+[^#]+"))) {
      flat_file_r_text <-
        flat_file_r_text |>
        str_replace_all("(#\\+[^#]*)[^A-z0-9#+ ]+([^#]+)", "\\1\\2")
    }
    return(flat_file_r_text)
  }

flat_file_r_text <-
  clean_chunk_titles(flat_file_r_text)

# check
# grep("how many are duals", flat_file_r_text, value = T) 

## find sourced files ----
# grep("source", flat_file_r_text, value = T)
# TODO: convert file to qmd and include

# comment out sourcing for flat files
comment_out_sources <-
  function(flat_file_r_text) {
    flat_file_r_text <-
      gsub("source\\(", "# source(", flat_file_r_text)
    return(flat_file_r_text)
  }

flat_file_r_text <- comment_out_sources(flat_file_r_text)

## Change all sections to a level lower ----
# works with the next step, convert %%%%% to the level 1
lower_section_level <-
  function(flat_file_r_text) {
    flat_file_r_text <-
      gsub("(#+) (.+)(----)",
           "\\1# \\2\\3",
           flat_file_r_text)
    return(flat_file_r_text)
  }

flat_file_r_text <-
  lower_section_level(flat_file_r_text)

## add 2 top sections ----
# E.g. "Prepare data" and "Plots", marked in the R script with #' %%%%%
# like #' %%%%% Prepare data
# not used in the auxiliary files

add_topmost_sections <- function(flat_file_r_text) {
  flat_file_r_text <-
    gsub("(%%%%%+) ", # was defined in the original .R
         "# ",
         flat_file_r_text)

  return(flat_file_r_text)
}

flat_file_r_text <-
  add_topmost_sections(flat_file_r_text)

## add layouts
add_layouts <- function(flat_file_r_text) {
  flat_file_r_text <-
    gsub(
      "(^#\\|)", # was defined in the original .R
      "#|",
      flat_file_r_text
    )
  return(flat_file_r_text)
}

flat_file_r_text <- add_layouts(flat_file_r_text)

# add "pretty" table output (add kable to glimpse)
add_pretty_table <-
  function(flat_file_r_text) {
    flat_file_r_text <-
      gsub(
      "(^ *[^#] +)(glimpse)(\\(\\S*\\))",
      # was in the original .R
      '\\1\\2\\3 |>
\\1knitr::kable(caption = "")',
flat_file_r_text
    )
    return(flat_file_r_text)
  }

flat_file_r_text <-
  add_pretty_table(flat_file_r_text)

# convert to Rmd ----
# The 'knitr::spin' function is used to create an R Markdown (Rmd) file, but the 'knit' argument is set to 'FALSE', indicating that the document should not be fully knitted. Instead, this function generates an Rmd file from the R script without executing the code chunks.

tictoc::tic("rmd_text")
rmd_text <-
  knitr::spin(text = flat_file_r_text,
              knit = FALSE,
              format = 'qmd')
tictoc::toc()
# rmd_text: 0.11 sec elapsed

# str(rmd_text)
#  chr [1:12684] "## Current file: useful_functions_module.r" ...

# Don't use in the auxiliary file
pre_text <- stringr::str_glue('---
title: {curent_project_name}
---
')

# Don't use in the auxiliary file
# Setup
setup_text <- "
```{r no cache setup, results='hide', message=FALSE, warning=FALSE, cache=FALSE, include=FALSE}

# A general-purpose tool for dynamic report generation in R
library(knitr)

# Adds features to a kable output
library(kableExtra)

# Format R code automatically
library(styler)

```

```{r df format setup}
#| include: false
# kable <- function(data) {
#   knitr::kable(data, booktabs = true, digits = 2) %>%
#     kable_styling('striped', full_width = FALSE)
# }

knit_print.data.frame = function(x, ...) {
  res = paste(c(
    '',
    '',
    knitr::kable(x, digits = 2) |>
      kableExtra::kable_styling('striped', full_width = FALSE)
  ),
  collapse = '\n')
  knitr::asis_output(res)
}

registerS3method(
  'knit_print', 'data.frame', knit_print.data.frame,
  envir = asNamespace('knitr')
)

# knitr::opts_chunk$set(echo = TRUE)

# options(knitr.table.format = 'HTML')


```
# save setup chunk options to use later
```{r setup current project, results='hide', message=FALSE, warning=FALSE}
```
"

# combine pieces into a Quarto file ----

# Don't use in the auxiliary file
cat(
  pre_text,
  file = file_paths$qmd,
  # append = TRUE,
  sep = "\n"
)

# ---
# add in front

# tabset doesn't work with TOC
cat(
  '::: {.panel-tabset}',
  file = file_paths$qmd,
  append = TRUE,
  sep = "\n"
)

# Don't use in the auxiliary file
cat(
  setup_text,
  file = file_paths$qmd,
  append = TRUE,
  sep = "\n"
)

cat(
  rmd_text,
  file = file_paths$qmd,
  append = TRUE,
  sep = "\n"
)

# for tabset only
cat(
  ':::',
  file = file_paths$qmd,
  append = TRUE,
  sep = "\n"
)
